На самом-то деле DFA это двумерный массив, исходя из этого я и сделаю формат. Формат: сначала идут три числа - n, m, q. m - кол-во букв в алфавите, n - кол-во состояний, q - начальное состояние.
Затем(на новой строке) m символов через пробел - это наш алфавит. Далее будем использовать не буквы, а числа i-й букве в этой строке будет соответствовать i - 1.
Затем следует n строк, по m чисел в каждой. Состояния - числа от  до n - 1, алфавит - числа от 0 до m - 1(всегда можно построить биекцию).
Число  x на i-й строке и j-м столбце означает что из состояния i и буквы j надо перейти в состояние с номером x. В конце следует строка на которой указаны терминальные состояния.

# Если a - это тот самый двумерый массив, то в коде это выглядело бы так :
# state = q, i = 0 
# for(...) state = a[state][word[i++] - 'a']

Примеры:

DFA принимающий все бинарные строки чётной длинны: 
2 2 0
0 1
1 1
0 0
0

------------------------------
DFA из первого пункта:

5 10 0
0 1 2 3 4 5 6 7 8 9
1 3 3 3 3 4 3 3 3 3
2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2
4 3 3 3 3 4 3 3 3 3
4 3 3 3 3 4 3 3 3 3
1 4

------------------------------
DFA из второго пункта:

13 2 0
a b
02 01
05 08
03 05
04 06
04 07
06 09
07 10
07 11
09 12
10 12
11 12
11 12
12 12
4 7 11
