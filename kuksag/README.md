# Парсер автоматов

## Запуск

```shell
pip3 install argparse attrs
python3 __main__.py [--input, -i input_file] [--output, -o output_file]
```

### Пример

```shell
python3 __main__.py -i data.in
```

Распарсит `data.in` и выведет результат в `stdout`

## Формат автоматов

* на первой строке `vertices num_1` -- количество вершин в автомате, где `num_1` количество вершин в автомате
* на второй строке `edges num_2` -- количество ребер в автомате, где `num_2` количество ребер в автомате
* на следующих `num_2` строк описаны ребра в формате `from a to b edge "edge_value"`, где `a, b, edge_value` две вершины автомата и символы на ребре соответственно
* затем стартовая вершина в формате `start num_3`
* далее `terminal num_4` -- описание терминальной вершины
* в конце `sink num_5` -- описание вершины, из которой нет ребер

Каждя строчка поданная на вход проверяется сначала на лексере, потом на парсере. 
Если вход не корректен, программа завершится со словами `bad input`.

## Структура программы

* `__main__.py` работает как консольное приложение, считывает выводит данные, вызывает метод `parse(line, log)` из `parser.py`

* `parse(line, log)` внутри себя вызывает `check_line(line, log)` из `lexer.py`; `log` -- опциональный параметр для логирования

* `parse(line, log)` автоматически определяет и возвращает объект (например, может вернуться `base.Edge` или `int`)

* в `__main.py__` собирается объект типа `base.FiniteStateMachine`, что и является результатом программы

## Тесты 

Тесты можно увидеть в `data*.in`

# Обзор коллег

## Егор Курагин

* Язык описания понятен
* Самый лучший парсер, что я когда либо видел
* Баг: плохо работает, когда стоит несколько пробелов, а не один
* пример работающего примера:
```
Alph = "0" "1"
States = 2
Start_state = 1
Accept_states = 2
Transits = (0, 1, "1") (1, 0, "1")
```
* пример некорректных данных
```
Alph ""
States = -5
Start_state = 0
Accept_states = 3
Transits = (0, 1, "1", 5, 42)
```

## Креславский Кириллл

* Второй самый лучший парсер, что я когда либо видел (его просто нет)
* язык описания понятен
* неточность: в языке есть типы Int, Char, String базовые, но алфавит может содержать объекты только одного типа
