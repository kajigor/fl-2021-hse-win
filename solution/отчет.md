# Постановка задачи

Нашей основной задачей являлось написание парсера для языка L, сравнимого по скорости с yacc и реализующего метод рекурсивного спуска. Для этого было необходмо разработать конкретный синтаксис языка L, написать для него парсер на yacc и свой собственный, сгенерировать тесты, которые будут долго разбираться обоими парсерами, и сравнить их время работы.

# Описание синтаксиса языка

Язык состоит из последовательных объявлений функций, после которых идет функция main. Если внутри функции вызывается функция, которая не была объявлена до нее, то это ошибка.

В языке присутствует четыре типа данных - натуральные числа, строковые литералы (и, как следствие, строки) и булевы значения, типам даны названия int, char, string, bool. 

Базовые выражения связываются операторами и образуют выражения (в описании языка L названо операторами то, что в дальнейшем здесь будет называться выражением). Выражения могут быть также связаны операторами и т.д. и таким образом образуют новые выражения.

Основные конструкции языка:

+ Операторы, идущие подряд, разделяются символом `;`. Также есть пустой оператор, он нужен для того, чтобы эффективно распознавать конец функции.

+ Условный оператор (ветвь else опциональна):

```
if (expr) {
expr
} else {
expr
};
```

+ Оператор цикла с предусловием

```
while (expr) {
expr
};
```

+ Оператор присвоения `:`

```
x : expr
```

+ Определение функции

```
func_name(type arg1 , type arg2 , type arg3) {
expr
}
```

+ Вызов функции 

```
func_name(arg1 , arg2 , arg3)
```

Зарезервированные имена, которые нельзя давать переменным и функциям: названия типов данных, while, if, else.

После любого выражения обязательно идет `;`, в том числе после циклов и т.д.

# Ход решения

Был определен синтаксис языка. Затем методом рекурсивного спуска был реализован парсер с разделением на парсинг функций, их объявлений и выражений в соответствии вышеописанному синтаксису. Также был реализован парсер на yacc, использующий лексер семейства lex, куда была просто внесена грамматика языка. 

Далее был написан генератор больших тестов, после чего программа запускала оба парсера на этих больших тестах и сравнивала их время работы. Результат получился приемлемым: парсер на yacc примерно в 3 раза быстрее.

![График](https://github.com/polupanovaanna/fl-2021-hse-win/blob/proj/solution/image.jpg)


В ходе работы основные сложности были с изучением библиотеки для написания парсера и аккуратным составлением грамматики, разбором всех случаев и всех токенов. Также были сложности при обработке больших тестов локально.

# Распределение задач:

Василевский Тимофей: написание парсера методом рекурсивного спуска, генерация больших тестов и сравнение времени работы.
Полупанова Анна: разработка и описание синтаксиса языка, написание лексера и парсера на yacc.
