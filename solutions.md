# 1

Далее: "числа через пробел" - означает что строка подходит под регулярное выражение `(\w|\s)*`, и между числами, `^` и `$` может быть `\s+`. В частности это значит что все числа целые и неотрицательные.    

Первая строка - сначала три символа `s: `, а затем четыре числа через пробел: `n, m, q, t`.  
`n` - кол-во состояний в автомате (состояния должны быть всеми целыми числами от `0` до `n - 1`(между конечными множествами состояний одинакового размера всегда можно построить биекцию)).  
`m` - кол-во букв/слов в алфавите.  
`q` - начальное состояние (не более `n - 1`).  
`t` - кол-во терминальных состояний.  
Далее `m` строк: слова алфавита, на которые действуют такие правила:  

* Каждая строка должна начинаться с трёх символов `w: `, а далее само слово.  

* Перенос строки - `\n`

* Cлеш - `\\`  

* Двойные кавычки - `\"`  

* Некорректное выражение - `x\y`, где `x != \` и `y != n` и `y != "`.

Далее `n` строк по `m` чисел через пробел. При этом каждая строка должна ничинаться с трёх символов: `n: `. Далее будем считать что нумерация строк начинается здесь. 
Все числа должны быть меньше `n`. Число `x` на `i`-й строке `j`-м столбце означает, что из состояния `i - 1` и `j`-го слова(в том порядке в котором они были указаны) надо перейти в состояние `x`.  
На последней строке три символа: `t: `, а затем `t` чисел через пробел - номера терминальных состояний.

## Пример

```
s: 2 2 0 1
w: a
w: b
n: 0 1
n: 1 0
t: 1
```

# 2

## 18

### Файлы

Корректные: `18_1.good, 18_2.good`
Некорректные: `18_1.bad, 18_2.bad`

### Описание

Описание в целом понятное, но по началу показалось, что слова алфавита могут быть только из одного символа. Пример есть.

### Удобство

Я, конечно, машина, но читать символы в двоичной системе не очень люблю. Перенос строки в конце файла -- какой-то костыль. В остальном норм.

### Поддержка в IDE

В PR который я проверяю никакого взаимодействия с IDE нет.

### Сообщения об ошибках

Если при перечислении рёбер ошибаешься в названии вершин, то получаешь исключение в лицо. В остальном норм.

### Неточности

Выходной файл не выглядит как структура данных. Явно неправильных автоматов обнаруженно не было. Но если символ - это перенос строки, то выхлоп парсера читать невозможно. 

## 20

### Файлы

Корректные: `20_1.good, 20_2.good`
Некорректные: `20_1.bad, 20_2.bad`

### Описание



### Удобство



### Поддержка в IDE



### Сообщения об ошибках



### Неточности



# 3

Тестовый просмотр файла с подсветкой: `./test.sh`  

`cd parser`  
Запуск: `./run.sh <input file>`  
Тестирование: `./test.sh`

# 4

Все описаные проверки будут сделаны во время парсинга. Тоесть если парсинг успешно завершился, то описанный автомат удовлетворяет всем проверкам.
