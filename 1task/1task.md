Для первого регулярного выражения получаем следующий детерминированный автомат:

![](https://github.com/olezhabobrov/fl-2021-hse-win/blob/HW02/1task/3.png?raw=true1.png)

Несложно заметить, что его можно минимизировать и получить:

![](https://github.com/olezhabobrov/fl-2021-hse-win/blob/HW02/1task/12.png?raw=true1.png)

Получился точно минимальный автомат, так как у нас только 2 состояния, одно из которых терминальное.

Теперь надо доказать, что данный автомат принимает те же слова, что и второе регулярное выражение.

То, что все слова, которые подходят под `((a | b)* b a | a) (a a)*` принимает наш автомат -- почти очевидно.
После `((a | b)* b a | a)` мы точно будем в терминальном положении: если в выражении просто `a`, то очевидно.
Если `(a | b)* b a`, то заметим, что после последнего `b` в выражении мы точно будем в левой вершине, а потом 
по `a` перейдем в правую. Остается только `(aa)*`. Так как количество а четное, то мы будем просто по циклу
крутится вокруг терминального состояния.

Теперь осталось доказать обратное, что все слова, которые принимает автомат, принимает и регулярное выражение.

Будем рассматривать слово до последнего `b`. Заметим, что мы остаемся в левом состоянии при любом количестве
`b` и `ab`, а это то же самое, что и `(a | b)* b`. После последнего `b` должно идти точно `a`, мы попадаем в 
терминальное состояние. Если в слове нет `b`, тогда первая буква `a`, и мы сразу попадаем в правую вершину.
Попали в правую вершину после `((a | b)* b a | a)`. Теперь мы можем там оставаться только после четного
количества `a` (`b` уже нет). Вот и получили мы наше регулярное выражение `((a | b)* b a | a) (a a)*`