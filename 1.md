# 1.

`b* a ((a | b) b* a)*`

Заметим, что в первом выражении, то что внутри скобок, спокойно может повторить то что находится снаружи, поэтому будем смотреть 
что генерируют скобки. А они генерируют любую строку из `а` и `b` кусками, в которых `а` только в конце, или где `а` в начале и конце, остальное возможно забито `b`. 

Теперь посмотрим как второе выражение примет такую строку. В первых скобках вынесем `а` и получим такое равносильное выражение

`((a | b)* b )? a (a a)*`

Заметим, что `((a | b)* b )? a` принимает любую строку, которая просто заканчивается на 1 `а`. А затем остальное в выражении может принимать строку из кусков `а а`.
То есть строку из первого выражения мы спокойно разберем, так как сначала возьмем все куски, и закончим последним куском содержащий хоть сколько `b` и одну `a` на конце, и, если есть, доберем кусками из `а а`.

Теперь смотрим какие строки генерирует второе выражение. Оно генерит любую строку из `a ` и `b`, затем завершает ее `ba`. 
А затем докидывает четное число `a`

Теперь посмотрим как его принимает 1 рег выражение. Оно скушает строку до первого `a` в строке, но так как у нас во втором выражении 
в первой скобке генерится вообще любая строка, которая в конце точно имеет `a`, то можем забить на то что вне скобок в первом выражении, так как строка может остаться точно такой же случайной из `a` и `b`.

Внутри скобок уже принимается строка кусками до первого встречного `a` имея в начале `a` или `b`. То есть мы случайную строку из двух букв поделили на куски вида `a b* a` и `b* a`. И мы так спокойно разделим, так как в конце у нас точно должна быть `a`. И так мы дойдем до заветного куска `ba` и доберем четное количество a, так как это тоже куски вида `a b* a`